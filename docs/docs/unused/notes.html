<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=edge"/><title>unused/notes · Indigo</title><meta name="viewport" content="width=device-width"/><meta name="generator" content="Docusaurus"/><meta name="description" content="Usually, game engines follow the Entity Component System (ECS) approach and this has yielded great results."/><meta name="docsearch:language" content="en"/><meta property="og:title" content="unused/notes · Indigo"/><meta property="og:type" content="website"/><meta property="og:url" content="https://your-docusaurus-test-site.com/"/><meta property="og:description" content="Usually, game engines follow the Entity Component System (ECS) approach and this has yielded great results."/><meta property="og:image" content="https://your-docusaurus-test-site.com/img/undraw_online.svg"/><meta name="twitter:card" content="summary"/><meta name="twitter:image" content="https://your-docusaurus-test-site.com/img/undraw_tweetstorm.svg"/><link rel="shortcut icon" href="/img/indigo_logo_solid.svg"/><link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=UA-169190516-1"></script><script>
              window.dataLayer = window.dataLayer || [];
              function gtag(){dataLayer.push(arguments); }
              gtag('js', new Date());
              gtag('config', 'UA-169190516-1');
            </script><script type="text/javascript" src="https://buttons.github.io/buttons.js"></script><script src="/js/scrollSpy.js"></script><link rel="stylesheet" href="/css/main.css"/><script src="/js/codetabs.js"></script></head><body class="sideNavVisible separateOnPageNav"><div class="fixedHeaderContainer"><div class="headerWrapper wrapper"><header><a href="/"><img class="logo" src="/img/indigo_logo_solid_text.svg" alt="Indigo"/><h2 class="headerTitleWithLogo">Indigo</h2></a><div class="navigationWrapper navigationSlider"><nav class="slidingNav"><ul class="nav-site nav-site-internal"><li class=""><a href="https://github.com/PurpleKingdomGames/indigo" target="_blank">GitHub</a></li><li class=""><a href="/docs/development-status" target="_self">Docs</a></li><li class=""><a href="/tools" target="_self">Tools</a></li></ul></nav></div></header></div></div><div class="navPusher"><div class="docMainWrapper wrapper"><div class="container mainContainer docsContainer"><div class="wrapper"><div class="post"><header class="postHeader"><h1 id="__docusaurus" class="postHeaderTitle">unused/notes</h1></header><article><div><span><p>Usually, game engines follow the Entity Component System (ECS) approach and this has yielded great results.</p>
<p>There are a number of drawbacks (depending on your point of view) with the usual crop of engines that Indigo tries to address with varying levels of success - it's far from perfect.</p>
<p>Some of the issues are:</p>
<ol>
<li>Older, error prone languages.</li>
<li>Difficulty in reasoning about the lifecycle of the game.</li>
<li>Compared to things like web development, relatively poor tooling experiences especially on non-windows platforms.</li>
</ol>
<p>Too begin addressing these, Indigo uses:</p>
<ol>
<li>Scala (which has it's own problems)</li>
<li>Functional programming and something inspired by the Functional Reactive Paradigm</li>
<li>Scala -&gt; JS &amp; WebGL as a compile target means cross platform dev tools are high quality. No special tools are needed but a few are supported.</li>
</ol>
<p>There are a few other side-quests too, for example, most of the gaming industries tooling is very Windows-centric, and I'm not. Even engines that purport to support Mac (like Unity) have relatively poor programming experiences on non-windows systems.</p>
<h2><a class="anchor" aria-hidden="true" id="functional-reactive-programming-frp--synchronous-programming"></a><a href="#functional-reactive-programming-frp--synchronous-programming" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Functional Reactive Programming (FRP) | Synchronous Programming</h2>
<p>If you squint when you look at it: Indigo looks like an FRP engine or a synchronous programming model and aims to behave like one. The hope is to move it further in that direction over time.</p>
<p>I'm a little cagey over whether this is FRP or Synchronous Programming. A lot of indigo's basic pattern was inspired by Elm. Elm started off being described as FRP but that has shifted a bit.</p>
<h3><a class="anchor" aria-hidden="true" id="what-is-frp-and-synchronous-programming-in-this-case"></a><a href="#what-is-frp-and-synchronous-programming-in-this-case" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>What is FRP and Synchronous Programming in this case?</h3>
<p>The most accessible description of FRP in frontend development, I think, is that it's a version of the MVC pattern that is <strong>NOT</strong> built using the Observer Pattern. The program flow is very simple:</p>
<ol>
<li>The game is initialised with config and a model</li>
<li>On each frame:
<ol>
<li>Game events (like the time) are passed to a model update function. The function takes the previous immutable version of the model and updates it creating a new, immutable instance.</li>
<li>This model instance is then passed, read only, to a view function that knows how to render it.</li>
<li>The view can generate events of it's own and these are passed to the event manager (controller?).</li>
<li>All the while, the event manager is listening for both view events and external inputs and batches them up ready for the next frame.</li>
</ol></li>
</ol>
<h4><a class="anchor" aria-hidden="true" id="win"></a><a href="#win" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Win?</h4>
<p>The beauty of this approach is it's simplicity. There is only one code path through the game / program. There are no event race conditions. There is no mutable state (as far as the game producer is concerned). The model can be processed lazily to aide calculations. Functions are all pure and easy to test. There is absolute separation of model, view, and controller concerns.</p>
<p>Sounds to good to be true right?</p>
<h4><a class="anchor" aria-hidden="true" id="drawbacks-of-frp"></a><a href="#drawbacks-of-frp" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>...drawbacks of FRP</h4>
<p>There are basically two issues with FRP.</p>
<p>The first is human: This isn't how we think about games. When you think &quot;tank&quot;, years of conditioning will have you thinking about attaching a script / class to it to control its movement and receive events when it's hit by another tank's shells and so on. That's not how FRP works, that's the ECS pattern in action and to be fair, the ECS pattern is popular because it's how we tend to naturally (or by conditioning) think about the problem space.</p>
<p>The second is that the criticism generally levelled at FRP is about performance. FRP engines come in all shapes and sizes but all of them are considered / perceived to be slow. There are exceptions, Elm is one of the fastest web languages / frameworks around and it is FRP based (although they've stopped using the term FRP). FRP engines allocate / construct objects a lot and require a lot of associated object clean up. Mutation is always faster but harder to reason about.</p>
<p>Indigo still needs further performance tuning at the time of writing. The reason it's been referred to here as being inspired by FRP is that the interface it's presents looks like an FRP interface, but the engine itself starts functional at a high level and becomes procedural down in it's guts so that it can work with WebGL. In between, there are a range of techniques used that FP purists would be unhappy about but give us the acceptable performance levels we have at the moment.</p>
<p>The aim for indigo is to provide a lovely functional programming experience that is a delight to make games with and easy to reason about, while hiding all the nastiness out of sight. This is optimising for programmer delight and productivity over raw engine performance.</p>
</span></div></article></div><div class="docs-prevnext"></div></div></div><nav class="onPageNav"><ul class="toc-headings"><li><a href="#functional-reactive-programming-frp--synchronous-programming">Functional Reactive Programming (FRP) | Synchronous Programming</a><ul class="toc-headings"><li><a href="#what-is-frp-and-synchronous-programming-in-this-case">What is FRP and Synchronous Programming in this case?</a></li></ul></li></ul></nav></div><footer class="nav-footer" id="footer"><section class="sitemap"><a href="/" class="nav-home"><img src="/img/indigo_logo.svg" alt="Indigo" width="66" height="58"/></a><div><h5>Getting Started</h5><a href="/docs/en/quickstart/setup-and-configuration">Setup &amp; Configuration Guide</a><a href="/docs/en/quickstart/hello-indigo">&quot;Hello, Indigo!&quot; Tutorial</a><a href="/docs/en/quickstart/examples">Links to examples</a></div><div><h5>Community</h5><a href="https://discord.gg/b5CD47g">Discord</a><a href="https://twitter.com/indigoengine" target="_blank" rel="noreferrer noopener">Twitter</a></div><div><h5>Sponsor us!</h5><a href="https://github.com/sponsors/PurpleKingdomGames">GitHub Sponsors</a><a href="https://www.patreon.com/indigoengine">Patreon</a></div></section><section class="copyright">Copyright © 2020 Purple Kingdom Games Limited</section></footer></div></body></html>